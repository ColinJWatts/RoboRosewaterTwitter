import os.path
import random
from PIL import Image
import io
import mimetypes
import requests
import sys
import json
from Managers.Logger import Logger
from selenium.webdriver import Chrome
from selenium.webdriver.chrome.options import Options
import time
import shutil

from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google_auth_oauthlib.flow import Flow
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from googleapiclient.http import MediaIoBaseDownload
from googleapiclient.http import MediaFileUpload

# This class requires authentication! 
# The config must point to a file containing a json blob of drive credentials downloaded from google's cert manager
TokenFileName = 'DriveTokenAutogenerated.txt'

class DriveImageManager:
    def __init__(self, config, alertService=None):
        self.config = config
        Logger.LogInfo("Starting Drive Manager")
        self.alertService = alertService
        try:
            # Do Authorization 
            Scopes = self.config["DriveScopes"]
            creds = None

            if os.path.exists(TokenFileName):
                Logger.LogInfo("Loading credentials from cache")
                creds = Credentials.from_authorized_user_file(TokenFileName, Scopes)
                creds.token = json.loads(open(TokenFileName, 'r').read())["token"]

            if not creds or not creds.valid:
                Logger.LogInfo("Downloading Credentials")
                flow = InstalledAppFlow.from_client_secrets_file(self.config["DriveSecretsFilePath"], Scopes)
                creds = flow.run_local_server(port=0)
                with open(TokenFileName, 'w') as token:
                    Logger.LogInfo("Cacheing credentials")
                    token.write(creds.to_json())

            self.service = build('drive', 'v3', credentials=creds)
        except Exception as e:
            Logger.LogError(f"Fatal Error Authenticating Google Drive with Excpetion: {e}", alertService)
            raise Exception(e) 

    def GetAuthCodeWithBrowserAutomation(self, url):
        # first we set up the browser to hide the automation from Google
        opts = Options()
        # default screen size can be an indicator of a bot running chrome
        opts.add_argument("start-maximized")
        # mock a user agent to fool google
        opts.add_argument(self.config["MockUserAgentArg"])
        # disable a bunch of automation flags that can potentially give it away
        opts.add_experimental_option("excludeSwitches", ["enable-automation"]) 
        opts.add_argument("--disable-blink-features")
        opts.add_argument('--disable-blink-features=AutomationControlled')
        opts.add_experimental_option('useAutomationExtension', False)

        # Make sure this is pointing to the hacked version of the chrome driver
        browser = Chrome(options=opts)
        # set it up so whenever a page is loaded we overwrite the get function for the webdriver flag
        # if this returns anything other than undefined google will know we're using a driver 
        browser.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", {
          "source": """
            Object.defineProperty(navigator, 'webdriver', {
              get: () => undefined
            })
          """
        })

        # load email credentials from secret file
        secretFile = open(self.config["EmailCredentialsPath"], "r")
        secrets = json.loads(secretFile.read())
        
        # Manual steps for authentication
        browser.get(url)
        time.sleep(1)
        emailField = browser.find_element_by_id("identifierId")
        emailField.send_keys(secrets["Email"])
        time.sleep(1)
        button = browser.find_element_by_id("identifierNext")
        button.click()
        time.sleep(1)
        pwform = browser.find_element_by_name("password")
        pwform.send_keys(secrets["Password"])
        time.sleep(1)
        button = browser.find_element_by_id("passwordNext")
        button.click()
        time.sleep(2)
        buttons = browser.find_elements_by_xpath("//button")
        for b in buttons:
            if "Continue" in b.text:
                b.click()
                break
        time.sleep(1)
        buttons = browser.find_elements_by_xpath("//button")
        for b in buttons:
            if "Continue" in b.text:
                b.click()
                break
        time.sleep(1)
        textarea = browser.find_element_by_xpath("//textarea")
        authCode = textarea.text
        browser.close()
        return authCode

    def RefreshCredentials(self):
        if os.path.exists(TokenFileName):
            os.remove(TokenFileName)

        flow = Flow.from_client_secrets_file(self.config["DriveSecretsFilePath"], self.config["DriveScopes"], redirect_uri='urn:ietf:wg:oauth:2.0:oob')
        auth_url, _ = flow.authorization_url(prompt='consent')
        authCode = self.GetAuthCodeWithBrowserAutomation(auth_url)
        flow.fetch_token(code=authCode)
        creds = flow.credentials
        self.service = build('drive', 'v3', credentials=creds)
        with open(TokenFileName, 'w') as token:
            Logger.LogInfo("Cacheing credentials")
            token.write(creds.to_json())

    def OldRefreshCredentials(self):
        Logger.LogInfo("Refreshing Credentials")
        creds = Credentials.from_authorized_user_file(TokenFileName, self.config["DriveScopes"])
        authorization_url = "https://oauth2.googleapis.com/token"
        params = {
                "grant_type": "refresh_token",
                "client_id": creds.client_id,
                "client_secret": creds.client_secret,
                "refresh_token": creds.refresh_token
        }

        r = requests.post(authorization_url, data=params)
        if r.ok:
            creds.token = r.json()["access_token"]
            self.service = build('drive', 'v3', credentials=creds)
            with open(TokenFileName, 'w') as token:
                    Logger.LogInfo("Cacheing credentials")
                    token.write(creds.to_json())
        else:
            raise Exception("Credential Refresh Failed")

    def PrintTokenInfo(self):
        token = json.loads(open(TokenFileName, 'r').read())["token"]
        print(token)
        url = f"https://www.googleapis.com/oauth2/v3/tokeninfo?access_token={token}"
        r = requests.get(url)
        if r.ok:
            print(r.json())
        else:
            print(sys.exc_info())


    def GetListOfAllImageInfo(self, folder):
        try:
            resource = self.service.files()
        except:
            self.RefreshCredentials()
            resource = self.service.files()
        pageToken = None
        result = []

        while True:
            response = resource.list(q=f"'{folder}' in parents", pageSize=100, fields="nextPageToken, files(id, name)", pageToken=pageToken).execute()
            result += response.get('files', [])
            pageToken = response.get('nextPageToken', None)
            if pageToken is None:
                break
        
        # filter to only supported file types
        result = [img for img in result if any(fileType in img['name'] for fileType in self.config["SupportedFileTypes"])]

        return result

    # Downloads a random image from drive and saves it in the local cache
    # returns a path to the downloaded image and the drive image info
    def DownloadRandomImage(self, folder):
        imageInfo = self.GetListOfAllImageInfo(folder)
        if (len(imageInfo) == 0):
            return None, None

        r = random.randrange(0, len(imageInfo))

        Logger.LogInfo(f"Downloading image: {imageInfo[r]['name']}")
        request = self.service.files().get_media(fileId=imageInfo[r]['id'])
        fileHandler = io.BytesIO()
        downloader = MediaIoBaseDownload(fileHandler, request)
        done = False
        while done is False:
            status, done = downloader.next_chunk()
        img = Image.open(fileHandler)
        path = os.path.join(self.config['DriveImageCachePath'], imageInfo[r]['name'])
        img.save(path)
        return path, imageInfo[r]

    def DownloadTextFileById(self, id, destination):
        Logger.LogInfo(f"Downloading text file with id: {id}")
        request = self.service.files().get_media(fileId=id)
        fileHandler = io.BytesIO()
        downloader = MediaIoBaseDownload(fileHandler, request)
        done = False
        while done is False:
            status, done = downloader.next_chunk()
        fileHandler.seek(0)

        with open(destination, 'wb') as f:
            shutil.copyfileobj(fileHandler, f)     


    # this just returns the image
    def DownloadCardById(self, id):
        Logger.LogInfo(f"Downloading card with id: {id}")
        request = self.service.files().get_media(fileId=id)
        fileHandler = io.BytesIO()
        downloader = MediaIoBaseDownload(fileHandler, request)
        done = False
        while done is False:
            status, done = downloader.next_chunk()
        img = Image.open(fileHandler)
        return img

    def RemoveImageById(self, id):
        Logger.LogInfo(f"Removing image from Drive with ID: {id}")
        self.service.files().delete(fileId=id).execute()

    def UploadImageToFolder(self, imgPath, folder):
        Logger.LogInfo(f"Uploading image to Drive: {self.GetFileNameFromPath(imgPath)}")
        fileMetadata = {
            'name' : os.path.basename(imgPath),
            'parents' : [folder]
        }
        media = MediaFileUpload(imgPath, mimetype=mimetypes.guess_type(imgPath)[0], resumable=True)
        newImgId = self.service.files().create(body=fileMetadata, media_body=media, fields='id').execute()

    # This function uses the above function to download an image 
    # it then remove that image from the source drive folder and puts it into the sink
    # returns the local filepath to the image
    def DownloadAndMoveRandomImage(self, folder, nonSinkFolderToMoveTo=None):
        localPath, driveImgInfo = self.DownloadRandomImage(folder)
        if (localPath is None):
            return None
        
        Logger.LogInfo(f"Deleting image {driveImgInfo['name']} from Source")
        self.service.files().delete(fileId=driveImgInfo['id']).execute()

        if nonSinkFolderToMoveTo is None:
            dest = self.config["SinkDriveFolder"]
        else:
            dest = nonSinkFolderToMoveTo

        fileMetadata = {
            'name' : driveImgInfo['name'],
            'parents' : [dest]
        }
        Logger.LogInfo(f"Uploading image {driveImgInfo['name']} to Sink")
        media = MediaFileUpload(localPath, mimetype=mimetypes.guess_type(localPath)[0], resumable=True)
        newImgId = self.service.files().create(body=fileMetadata, media_body=media, fields='id').execute()
        return localPath

    # gets the name of the file
    def GetFileNameFromPath(self, path):
        filename = os.path.basename(path)

        # strip file extention
        for x in self.config["SupportedFileTypes"]: 
            filename = filename.replace(x, "")

        return filename